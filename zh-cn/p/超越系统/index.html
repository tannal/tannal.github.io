<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="重新定义算法：基于经典逻辑公理的系统分析 摘要 本文旨在从经典逻辑的三大基本定律——同一律、矛盾律和排中律——的视角，重新审视“算法”的定义及其在不同计算系统中的行为。我们提出“经典系统”的概念，其核心运算机制严格遵循上述逻辑定律，并探讨其在离散计算、层级结构及确定性推导中的应用与局限（特别是自指问题）。随后，我们将引入“超越系统”的概念，分析其如何突破或以不同方式诠释经典逻辑定律，并以图结构和神经网络为例，揭示其在处理非确定性、模糊性及复杂涌现现象时的独特能力。\n引言：经典逻辑定律的基石 在逻辑学中，同一律（Law of Identity）、**矛盾律（Law of Non-Contradiction）和排中律（Law of Excluded Middle）**构成了经典逻辑的基石，为人类的理性思维和科学推理提供了根本框架。\n同一律 (Law of Identity)：A 是 A (A = A)。它强调事物的自身同一性，即任何事物在任何时刻都与其自身保持一致。这是概念清晰和识别的基础。 矛盾律 (Law of Non-Contradiction)：A 不能既是 A 又不是 A (¬(A ∧ ¬A))。它排除了事物同时具有矛盾性质的可能性，确保了逻辑上的一致性和非二义性。 排中律 (Law of Excluded Middle)：一个命题要么是真的，要么是假的，没有第三种可能性 (P ∨ ¬P)。它确立了真值二分性，是逻辑推理和决策的基础。 这三大定律不仅是形式逻辑的根本，也深刻地影响了我们对计算、系统以及“算法”本质的理解。\n重新定义算法与经典系统 我们重新定义“算法”为：沿着一个明确方向单向前进，并在过程中建立起沿方向传递的单调或独立性质的计算机程序。这种定义的核心在于其对确定性和有序性的强调，而这正是经典逻辑定律在计算领域中的体现。\n我们提出，经典系统是指那些其基本操作和结构严格遵循同一律、矛盾律和排中律的系统。具体而言，它们表现出以下性质：\n自反性质（Reflexivity）：个体等于自身。这直接对应于同一律。在经典系统中，每个计算实体、每个数据点都有明确的、不含糊的身份，我等于我自己。这使得我们能够唯一地标识和引用对象。 区别性质（Distinction）：除了自身以外，没有其他个体与自身完全相同。这根植于矛盾律。如果一个实体是 A，则它不可能同时不是 A，从而能够明确地将 A 与非 A 区分开来。除了我以外没人跟我一样，这种非矛盾性确保了离散元素的清晰边界。 传递性质（Transitivity）：如果 A 具有与 B 的某种关系，且 B 具有与 C 的相同关系，那么 A 也具有与 C 的该关系。例如，如果 a > b 且 b > c，则 a > c。这种性质在经典系统中尤为重要，它允许建立层级关系（如“鄙视链机制”）和单向因果链。我跟别人不一样，不仅不一样，一定能分出高下。 排中律在经典系统中的应用则体现在其决策和流程的二元性上：每一步计算、每个条件判断的结果都是明确的“真”或“假”，没有中间状态。这种确定性是经典算法（如排序算法、搜索算法）能够有效运作的基础。\n"><title>超越系统</title><link rel=canonical href=https://tannal.github.io/zh-cn/p/%E8%B6%85%E8%B6%8A%E7%B3%BB%E7%BB%9F/><link rel=stylesheet href=/scss/style.min.b0e76e98cdd4f7082d1fc36f7af7e0843a81201db2197c03ca426751dc923735.css><meta property='og:title' content="超越系统"><meta property='og:description' content="重新定义算法：基于经典逻辑公理的系统分析 摘要 本文旨在从经典逻辑的三大基本定律——同一律、矛盾律和排中律——的视角，重新审视“算法”的定义及其在不同计算系统中的行为。我们提出“经典系统”的概念，其核心运算机制严格遵循上述逻辑定律，并探讨其在离散计算、层级结构及确定性推导中的应用与局限（特别是自指问题）。随后，我们将引入“超越系统”的概念，分析其如何突破或以不同方式诠释经典逻辑定律，并以图结构和神经网络为例，揭示其在处理非确定性、模糊性及复杂涌现现象时的独特能力。\n引言：经典逻辑定律的基石 在逻辑学中，同一律（Law of Identity）、**矛盾律（Law of Non-Contradiction）和排中律（Law of Excluded Middle）**构成了经典逻辑的基石，为人类的理性思维和科学推理提供了根本框架。\n同一律 (Law of Identity)：A 是 A (A = A)。它强调事物的自身同一性，即任何事物在任何时刻都与其自身保持一致。这是概念清晰和识别的基础。 矛盾律 (Law of Non-Contradiction)：A 不能既是 A 又不是 A (¬(A ∧ ¬A))。它排除了事物同时具有矛盾性质的可能性，确保了逻辑上的一致性和非二义性。 排中律 (Law of Excluded Middle)：一个命题要么是真的，要么是假的，没有第三种可能性 (P ∨ ¬P)。它确立了真值二分性，是逻辑推理和决策的基础。 这三大定律不仅是形式逻辑的根本，也深刻地影响了我们对计算、系统以及“算法”本质的理解。\n重新定义算法与经典系统 我们重新定义“算法”为：沿着一个明确方向单向前进，并在过程中建立起沿方向传递的单调或独立性质的计算机程序。这种定义的核心在于其对确定性和有序性的强调，而这正是经典逻辑定律在计算领域中的体现。\n我们提出，经典系统是指那些其基本操作和结构严格遵循同一律、矛盾律和排中律的系统。具体而言，它们表现出以下性质：\n自反性质（Reflexivity）：个体等于自身。这直接对应于同一律。在经典系统中，每个计算实体、每个数据点都有明确的、不含糊的身份，我等于我自己。这使得我们能够唯一地标识和引用对象。 区别性质（Distinction）：除了自身以外，没有其他个体与自身完全相同。这根植于矛盾律。如果一个实体是 A，则它不可能同时不是 A，从而能够明确地将 A 与非 A 区分开来。除了我以外没人跟我一样，这种非矛盾性确保了离散元素的清晰边界。 传递性质（Transitivity）：如果 A 具有与 B 的某种关系，且 B 具有与 C 的相同关系，那么 A 也具有与 C 的该关系。例如，如果 a > b 且 b > c，则 a > c。这种性质在经典系统中尤为重要，它允许建立层级关系（如“鄙视链机制”）和单向因果链。我跟别人不一样，不仅不一样，一定能分出高下。 排中律在经典系统中的应用则体现在其决策和流程的二元性上：每一步计算、每个条件判断的结果都是明确的“真”或“假”，没有中间状态。这种确定性是经典算法（如排序算法、搜索算法）能够有效运作的基础。\n"><meta property='og:url' content='https://tannal.github.io/zh-cn/p/%E8%B6%85%E8%B6%8A%E7%B3%BB%E7%BB%9F/'><meta property='og:site_name' content='谭盟'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='计算机'><meta property='article:tag' content='逻辑'><meta property='article:published_time' content='2025-06-14T00:00:00+00:00'><meta property='article:modified_time' content='2025-06-14T00:00:00+00:00'><meta name=twitter:title content="超越系统"><meta name=twitter:description content="重新定义算法：基于经典逻辑公理的系统分析 摘要 本文旨在从经典逻辑的三大基本定律——同一律、矛盾律和排中律——的视角，重新审视“算法”的定义及其在不同计算系统中的行为。我们提出“经典系统”的概念，其核心运算机制严格遵循上述逻辑定律，并探讨其在离散计算、层级结构及确定性推导中的应用与局限（特别是自指问题）。随后，我们将引入“超越系统”的概念，分析其如何突破或以不同方式诠释经典逻辑定律，并以图结构和神经网络为例，揭示其在处理非确定性、模糊性及复杂涌现现象时的独特能力。\n引言：经典逻辑定律的基石 在逻辑学中，同一律（Law of Identity）、**矛盾律（Law of Non-Contradiction）和排中律（Law of Excluded Middle）**构成了经典逻辑的基石，为人类的理性思维和科学推理提供了根本框架。\n同一律 (Law of Identity)：A 是 A (A = A)。它强调事物的自身同一性，即任何事物在任何时刻都与其自身保持一致。这是概念清晰和识别的基础。 矛盾律 (Law of Non-Contradiction)：A 不能既是 A 又不是 A (¬(A ∧ ¬A))。它排除了事物同时具有矛盾性质的可能性，确保了逻辑上的一致性和非二义性。 排中律 (Law of Excluded Middle)：一个命题要么是真的，要么是假的，没有第三种可能性 (P ∨ ¬P)。它确立了真值二分性，是逻辑推理和决策的基础。 这三大定律不仅是形式逻辑的根本，也深刻地影响了我们对计算、系统以及“算法”本质的理解。\n重新定义算法与经典系统 我们重新定义“算法”为：沿着一个明确方向单向前进，并在过程中建立起沿方向传递的单调或独立性质的计算机程序。这种定义的核心在于其对确定性和有序性的强调，而这正是经典逻辑定律在计算领域中的体现。\n我们提出，经典系统是指那些其基本操作和结构严格遵循同一律、矛盾律和排中律的系统。具体而言，它们表现出以下性质：\n自反性质（Reflexivity）：个体等于自身。这直接对应于同一律。在经典系统中，每个计算实体、每个数据点都有明确的、不含糊的身份，我等于我自己。这使得我们能够唯一地标识和引用对象。 区别性质（Distinction）：除了自身以外，没有其他个体与自身完全相同。这根植于矛盾律。如果一个实体是 A，则它不可能同时不是 A，从而能够明确地将 A 与非 A 区分开来。除了我以外没人跟我一样，这种非矛盾性确保了离散元素的清晰边界。 传递性质（Transitivity）：如果 A 具有与 B 的某种关系，且 B 具有与 C 的相同关系，那么 A 也具有与 C 的该关系。例如，如果 a > b 且 b > c，则 a > c。这种性质在经典系统中尤为重要，它允许建立层级关系（如“鄙视链机制”）和单向因果链。我跟别人不一样，不仅不一样，一定能分出高下。 排中律在经典系统中的应用则体现在其决策和流程的二元性上：每一步计算、每个条件判断的结果都是明确的“真”或“假”，没有中间状态。这种确定性是经典算法（如排序算法、搜索算法）能够有效运作的基础。\n"><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/zh-cn/><img src=/img/avatar_hu_23460dfa2f6975f3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🤟</span></figure><div class=site-meta><h1 class=site-name><a href=/zh-cn>谭盟</a></h1><h2 class=site-description>stay hungry, stay foolish</h2></div></header><ol class=menu-social><li><a href=https://space.bilibili.com/3546751254399476 target=_blank title="B 站「起个名字叫犟驴」" rel=me><!doctype html><svg t="1712105268862" class="icon" viewBox="0 0 1024 1024" p-id="5725" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M1019.54782609 345.3106087c-3.20556522-142.1133913-127.15408696-169.36069565-127.15408696-169.36069566s-96.70121739-.53426087-222.25252174-1.60278261l91.3586087-88.15304347s14.42504348-18.16486957-10.15095652-38.46678261c-24.576-20.30191304-26.17878261-11.21947826-34.72695653-5.87686957-7.47965217 5.3426087-117.00313043 112.72904348-136.23652174 131.96243479-49.68626087.0-101.50956522-.53426087-151.73008695-.53426087h17.63060869S315.392 43.98747826 306.84382609 38.1106087s-9.61669565-14.42504348-34.72695652 5.87686956c-24.576 20.30191304-10.15095652 38.46678261-10.15095653 38.46678261l93.49565218 90.82434783c-101.50956522.0-189.12834783.53426087-229.73217392 2.13704347C-5.69878261 213.34817391 4.45217391 345.3106087 4.45217391 345.3106087s1.60278261 283.15826087.0 426.34017391c14.42504348 143.18191304 124.48278261 166.15513043 124.48278261 166.15513043s43.8093913 1.06852174 76.39930435 1.06852174c3.20556522 9.08243478 5.87686957 53.96034783 56.0973913 53.96034783 49.68626087.0 56.0973913-53.96034783 56.09739131-53.96034783s365.96869565-1.60278261 396.42156522-1.60278261c1.60278261 15.49356522 9.08243478 56.63165217 59.30295652 56.09739131 49.68626087-1.06852174 53.42608696-59.30295652 53.42608695-59.30295652s17.09634783-1.60278261 67.85113044.0c118.60591304-21.90469565 125.55130435-160.81252174 125.55130435-160.81252174s-2.13704348-285.82956522-.53426087-427.94295652zM917.504 798.36382609c0 22.43895652-17.6306087 40.60382609-39.53530435 40.60382608H156.71652174c-21.90469565.0-39.53530435-18.16486957-39.53530435-40.60382608V320.20034783c0-22.43895652 17.6306087-40.60382609 39.53530435-40.60382609h721.25217391c21.90469565.0 39.53530435 18.16486957 39.53530435 40.60382609v478.16347826z" fill="#8a8a8a" p-id="5726"/><path d="M409.088 418.816l-203.264 38.912 17.408 76.288 201.216-38.912zm109.568 202.24c-49.664 106.496-94.208 26.112-94.208 26.112l-33.28 21.504s65.536 89.6 128 21.504c73.728 68.096 130.048-22.016 130.048-22.016l-30.208-19.456c0-.512-52.736 75.776-100.352-27.648zM619.008 495.104l201.728 38.912 16.896-76.288-202.752-38.912z" fill="#8a8a8a" p-id="5727"/></svg></a></li><li><a href=https://github.com/tannal target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://twitter.com/megotannal target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li><li><a href=https://www.zhihu.com/people/roseduan target=_blank title=Zhihu rel=me><!doctype html><svg t="1704259577746" class="icon" viewBox="0 0 1024 1024" p-id="5040" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M570.581333 806.272h61.952L652.928 876.117333 764.074667 806.272h130.986666V230.186667h-324.48V806.272zM636.501333 292.693333h192.64V743.68h-73.898666l-73.813334 46.378667L668.032 743.808l-31.530667-.128V292.736zM515.754667 493.738667H377.429333a2999.466667 2999.466667.0 005.802667-194.56h135.338667S523.776 239.445334 495.872 240.128H261.76c9.216-34.730667 20.821333-70.613333 34.688-107.690667.0.0-63.701333.0-85.333333 57.130667C202.112 213.12 176.128 303.786667 129.877333 396.416c15.573333-1.706667 67.114667-3.114667 97.450667-58.794667 5.589333-15.616 6.656-17.621333 13.568-38.485333h76.373333c0 27.776-3.157333 177.109333-4.437333 194.474667h-138.24c-31.104.0-41.173333 62.549333-41.173333 62.549333h173.482666C295.253333 688.256 232.789333 799.573333 119.466667 887.466667c54.186667 15.488 108.202667-2.432 134.912-26.197334.0.0 60.8-55.338667 94.122666-183.381333L491.264 849.834667s20.906667-71.168-3.285333-105.856c-20.053333-23.637333-74.24-87.552-97.322667-110.72l-38.698667 30.72c11.52-36.992 18.474667-72.96 20.821334-107.690667h163.072s-.213333-62.549333-20.053334-62.549333z" p-id="5041" fill="#8a8a8a"/></svg></a></li><li><a href=https://mp.weixin.qq.com/s/hs36eiU7Zr-UdJ0YBtZgKQ target=_blank title="微信公众号 roseduan写字的地方" rel=me><!doctype html><svg t="1704259948565" class="icon" viewBox="0 0 1194 1024" p-id="5272" xmlns:xlink="http://www.w3.org/1999/xlink" width="233.203125" height="200"><path d="M728.064 535.296a35.498667 35.498667.0 11-70.912.0 35.498667 35.498667.0 0170.912.0m246.016.0a35.498667 35.498667.0 11-70.997333.0 35.498667 35.498667.0 0170.997333.0" fill="#8a8a8a" p-id="5273"/><path d="M902.144 930.133333l-6.656 1.450667a594.176 594.176.0 01-18.602667 3.669333c-26.453333 4.778667-44.629333 6.826667-64 6.144C645.034666 935.850666 514.218666 853.504 461.824 722.688a446.464 446.464.0 01-6.826667-19.114667l-1.962666-6.058666a199.68 199.68.0 01-3.84-13.653334 338.858667 338.858667.0 01-9.216-75.690666c0-171.008 157.013333-305.92 354.304-314.709334l8.874666-.682666c7.850667-.597333 12.970667-.853333 18.773334-.853334h14.762666l9.301334.170667c188.16 14.677333 340.394667 156.672 340.394666 323.925333.0 78.336-38.826667 155.733333-109.653333 222.293334a303.530667 303.530667.0 01-7.082667 6.4l9.984 71.082666a49.152 49.152.0 01-69.12 58.453334l-98.816-46.421334a582.485333 582.485333.0 01-9.472 2.304zm220.16-314.026666c0-131.754667-124.586667-247.978667-279.125333-260.096H821.930667c-3.754667.0-7.68.085333-13.994667.597333l-10.666667.768C631.466667 364.8 503.978667 474.453333 503.978667 608.256c0 18.773333 2.730667 40.874667 7.509333 60.842667.597333 2.474667 1.450667 5.632 2.56 9.216l1.706667 4.949333c2.133333 6.570667 4.266667 12.629333 5.632 15.957333 42.325333 105.728 149.930667 173.397333 293.717333 178.176 13.738667.512 28.16-1.109333 50.346667-5.12a531.626667 531.626667.0 0016.64-3.242666l5.632-1.28c4.693333-1.109333 8.448-1.962667 19.370666-4.778667a32 32 0 0121.418667 2.133333L1013.76 905.216l-9.984-69.290667a32 32 0 0113.909333-31.232c1.194667-.853333 8.618667-6.912 15.189334-13.056 58.709333-55.210667 89.429333-116.394667 89.429333-175.616zM12.970667 378.197333C12.970667 171.52 206.677333 5.376 442.709333 5.376c208.384.0 394.24 130.304 431.872 306.090667 1.28 5.973333 1.28 11.264.512 16.896a32 32 0 01-63.658666-5.973334C779.178667 179.2 621.482667 69.376 442.709333 69.376c-202.666666.0-365.738666 139.776-365.738666 308.906667.0 89.941333 46.165333 171.52 136.021333 237.568a32 32 0 0111.434667 35.84l-23.296 69.973333 104.96-48.896a32 32 0 0122.442666-1.706667l5.461334 1.706667c54.357333 11.093333 76.288 14.506667 108.714666 14.506667a200.789333 200.789333.0 0032.256-4.010667c-.512.170667-1.536.512-2.730666 1.536a33.109333 33.109333.0 0139.253333 1.109333A32 32 0 01516.864 730.88c-11.776 14.848-47.36 20.309333-74.24 20.309333-37.12.0-62.037333-3.584-119.893333-15.530666L198.570667 793.6a49.493333 49.493333.0 01-68.949334-59.733333l26.88-80.64c-93.525333-75.52-143.530666-170.24-143.530666-275.029334z" fill="#8a8a8a" p-id="5274"/><path d="M344.576 254.378667a44.373333 44.373333.0 11-88.746667.085333 44.373333 44.373333.0 0188.746667.0M636.586667 254.378667A44.373333 44.373333.0 11547.84 254.464a44.373333 44.373333.0 0188.746667.0" fill="#8a8a8a" p-id="5275"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/zh-cn/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/zh-cn/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/zh-cn/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/zh-cn/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M8 7a4 4 0 108 0A4 4 0 008 7"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://tannal.github.io/>English</option><option value=https://tannal.github.io/zh-cn/ selected>Chinese</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#重新定义算法基于经典逻辑公理的系统分析>重新定义算法：基于经典逻辑公理的系统分析</a><ol><li><a href=#摘要>摘要</a></li><li><a href=#引言经典逻辑定律的基石>引言：经典逻辑定律的基石</a></li><li><a href=#重新定义算法与经典系统>重新定义算法与经典系统</a></li><li><a href=#经典系统的挑战自指问题>经典系统的挑战：自指问题</a></li><li><a href=#超越系统模糊与概率的世界>超越系统：模糊与概率的世界</a></li><li><a href=#神经网络经典与超越的交汇>神经网络：经典与超越的交汇</a></li></ol></li><li><a href=#你说的超越系统不就是集合论加概率么有什么区别>你说的超越系统不就是集合论加概率么？有什么区别？</a><ol><li><a href=#经典系统--经典概率柯尔莫哥洛夫公理化>经典系统 + 经典概率（柯尔莫哥洛夫公理化）</a></li><li><a href=#超越系统--非经典概率如模糊概率量子概率>超越系统 + 非经典概率（如模糊概率、量子概率）</a></li><li><a href=#总结类比>总结类比</a></li><li><a href=#经典系统推理的领域>经典系统：推理的领域</a></li><li><a href=#超越系统类比的领域>超越系统：类比的领域</a></li><li><a href=#我们不是推理机器我们是类比机器>我们不是推理机器，我们是类比机器</a></li><li><a href=#经典系统依赖推理的例子>经典系统：依赖推理的例子</a></li><li><a href=#超越系统依赖类比的例子>超越系统：依赖类比的例子</a></li><li><a href=#结论>结论</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/zh-cn/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/>神经网络</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/zh-cn/p/%E8%B6%85%E8%B6%8A%E7%B3%BB%E7%BB%9F/>超越系统</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2025-06-14T00:00:00Z>Jun 14, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 3 分钟</time></div></footer></div></header><section class=article-content><h2 id=重新定义算法基于经典逻辑公理的系统分析>重新定义算法：基于经典逻辑公理的系统分析</h2><h3 id=摘要>摘要</h3><p>本文旨在从经典逻辑的三大基本定律——同一律、矛盾律和排中律——的视角，重新审视“算法”的定义及其在不同计算系统中的行为。我们提出“经典系统”的概念，其核心运算机制严格遵循上述逻辑定律，并探讨其在离散计算、层级结构及确定性推导中的应用与局限（特别是自指问题）。随后，我们将引入“超越系统”的概念，分析其如何突破或以不同方式诠释经典逻辑定律，并以图结构和神经网络为例，揭示其在处理非确定性、模糊性及复杂涌现现象时的独特能力。</p><h3 id=引言经典逻辑定律的基石>引言：经典逻辑定律的基石</h3><p>在逻辑学中，<strong>同一律（Law of Identity）</strong>、**矛盾律（Law of Non-Contradiction）<strong>和</strong>排中律（Law of Excluded Middle）**构成了经典逻辑的基石，为人类的理性思维和科学推理提供了根本框架。</p><ol><li><strong>同一律 (Law of Identity)</strong>：A 是 A (A = A)。它强调事物的自身同一性，即任何事物在任何时刻都与其自身保持一致。这是概念清晰和识别的基础。</li><li><strong>矛盾律 (Law of Non-Contradiction)</strong>：A 不能既是 A 又不是 A (¬(A ∧ ¬A))。它排除了事物同时具有矛盾性质的可能性，确保了逻辑上的一致性和非二义性。</li><li><strong>排中律 (Law of Excluded Middle)</strong>：一个命题要么是真的，要么是假的，没有第三种可能性 (P ∨ ¬P)。它确立了真值二分性，是逻辑推理和决策的基础。</li></ol><p>这三大定律不仅是形式逻辑的根本，也深刻地影响了我们对计算、系统以及“算法”本质的理解。</p><h3 id=重新定义算法与经典系统>重新定义算法与经典系统</h3><p>我们重新定义“算法”为：沿着一个明确方向单向前进，并在过程中建立起沿方向传递的单调或独立性质的计算机程序。这种定义的核心在于其对<strong>确定性</strong>和<strong>有序性</strong>的强调，而这正是经典逻辑定律在计算领域中的体现。</p><p>我们提出，<strong>经典系统</strong>是指那些其基本操作和结构严格遵循同一律、矛盾律和排中律的系统。具体而言，它们表现出以下性质：</p><ul><li><strong>自反性质（Reflexivity）</strong>：个体等于自身。这直接对应于<strong>同一律</strong>。在经典系统中，每个计算实体、每个数据点都有明确的、不含糊的身份，<code>我等于我自己</code>。这使得我们能够唯一地标识和引用对象。</li><li><strong>区别性质（Distinction）</strong>：除了自身以外，没有其他个体与自身完全相同。这根植于<strong>矛盾律</strong>。如果一个实体是 A，则它不可能同时不是 A，从而能够明确地将 A 与非 A 区分开来。<code>除了我以外没人跟我一样</code>，这种非矛盾性确保了离散元素的清晰边界。</li><li><strong>传递性质（Transitivity）</strong>：如果 A 具有与 B 的某种关系，且 B 具有与 C 的相同关系，那么 A 也具有与 C 的该关系。例如，如果 <code>a > b</code> 且 <code>b > c</code>，则 <code>a > c</code>。这种性质在经典系统中尤为重要，它允许建立<strong>层级关系</strong>（如“鄙视链机制”）和<strong>单向因果链</strong>。<code>我跟别人不一样，不仅不一样，一定能分出高下</code>。</li></ul><p><strong>排中律</strong>在经典系统中的应用则体现在其决策和流程的二元性上：每一步计算、每个条件判断的结果都是明确的“真”或“假”，没有中间状态。这种确定性是经典算法（如排序算法、搜索算法）能够有效运作的基础。</p><p><strong>传递性质的利用是算法时间复杂度差异的来源。</strong> 简单来说，利用传递性质分批处理能够减小算法的时间复杂度。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>SortingAlgorithms</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 1. 传递性质的利用 - 确保比较的有效性与可传递性</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>class</span> <span class=nc>TransitiveProperty</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>void</span><span class=w> </span><span class=nf>compare</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// if a &gt; b &amp;&amp; b &gt; c then a &gt; c</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 这个性质允许我们：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 1. 不需要比较所有对 (通过传递性推断)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 2. 可以批量处理 (基于序关系进行分组)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 3. 保证结果正确性 (基于逻辑一致性)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 2. 不同批次大小的实现 - 排中律确保了每次比较的明确结果</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>class</span> <span class=nc>BatchProcessing</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 插入排序 (批次=1) - O(n^2) - 每次确定一个元素位置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>void</span><span class=w> </span><span class=nf>insertionSort</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* ... existing code ... */</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 归并排序 (批次=n/2) - O(n log n) - 每次处理一半数据，利用传递性进行合并</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>void</span><span class=w> </span><span class=nf>mergeSort</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* ... existing code ... */</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 快速排序 (批次=基于pivot的分区) - O(n log n) - 动态批次大小，利用明确的划分</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>void</span><span class=w> </span><span class=nf>quickSort</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* ... existing code ... */</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 堆排序 (批次=堆的层级) - O(n log n) - 稳定的批处理，基于层级（传递性）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>void</span><span class=w> </span><span class=nf>heapSort</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=cm>/* ... existing code ... */</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>计算机，作为经典的、基于图灵机模型的计算设备，其本质上只能处理有明确方向性并沿着该方向性传递单调或独立性质的结构。例如，计算机科学中的树结构是层级系统（层级关系依赖于传递性）的最完美体现。时间在分布式系统中被理解为事件的发生顺序，其“顺序”概念同样满足这三条经典性质。</p><h3 id=经典系统的挑战自指问题>经典系统的挑战：自指问题</h3><p>经典系统中的第一大难题，也是造成无数科学、数学和计算机系统问题的根源，就是<strong>自指（Self-reference）</strong>。自指现象，例如语言中的歧义、逻辑悖论（如罗素悖论）、图灵机的停机问题和不可判定问题，其根源往往可以追溯到<strong>同一律的滥用或边界模糊</strong>。当一个系统尝试对其自身进行定义或操作时，同一律的简单应用可能会导致循环定义或无限递归。</p><p>然而，计算机科学家已经发展出无数的策略来应付自指，甚至主动创造自指以实现强大的功能（例如编译器自举、虚拟机嵌套、运行时环境中的自模拟）。这表明，尽管自指是经典系统的一个内在挑战，但通过精巧的设计和分层抽象，可以将其纳入可控的范围。</p><h3 id=超越系统模糊与概率的世界>超越系统：模糊与概率的世界</h3><p>与经典系统不同，<strong>超越系统</strong>是那些不严格遵循或以不同方式诠释同一律、矛盾律和排中律的系统。它们的核心特征是从刻画“相等”与“不等”转向刻画“相似”与“不相似”。</p><ul><li><strong>相似性质（Similarity）</strong>：个体与自身相似。这取代了严格的<strong>同一律</strong>。在超越系统中，<code>我与我自己相似</code>，<code>每一刻的"我"都是不同的</code>，<code>只有相似，没有相等</code>。这意味着即使是“自己”的概念也是模糊且连续变化的，不存在绝对的同一性。</li><li><strong>区别性质（Dissimilarity）</strong>：个体与他人不相似。与经典系统的明确“区别”不同，这里的“不相似”可能无法区分高下，或者边界是模糊的。这削弱了<strong>矛盾律</strong>的绝对性，允许中间地带或重叠区域的存在。<code>我与别人的不相似，无法区分高下</code>，<code>无法确定"自己"</code>，<code>“我"是模糊的概念 边界是不确定的</code>。</li><li><strong>平等性质（Equality of Dissimilarity）</strong>：我与别人的不相似，无法区分高下。这不同于传递性所形成的严格等级，暗示着某种程度的无序性和复杂性。</li></ul><p><strong>排中律</strong>在超越系统中也面临挑战。由于其内在的模糊性、概率性或非线性行为，一个命题可能无法简单地被判定为“真”或“假”。例如，神经网络的分类结果是“概率分布”，而非简单的二元判断。这表明存在“第三种可能性”——即某种程度的真或某种程度的假。</p><p>超越系统典型的例子包括：生命体群体行为（股市、蚁群）、量子力学、经典力学的三体系统、人类直觉（System 1）、大语言模型、感知与意识、艺术创作以及哥德尔不完备定理揭示的现象。</p><p>在超越系统中，因果循环现象（如“上海经济”的例子）非常普遍，它打破了经典系统的单向因果链。计算机科学中的图结构，特别是<strong>一般图</strong>（非有向无环图），其节点之间的关系可以用相似性（而非严格相等）来刻画强弱，且不具备明显的层次结构和传递性，因此被视为超越系统的典型代表，并涵盖了大量的NP问题。</p><h3 id=神经网络经典与超越的交汇>神经网络：经典与超越的交汇</h3><p>大语言模型等神经网络是计算机科学家利用经典系统实现超越系统的奇迹，这从侧面印证了哥德尔不完备定理的普适性——在足够强大的经典系统中，总能发现无法通过该系统自身完整证明的“超越”现象。</p><p>神经网络的实现（Implementation）必须受到其运行的经典计算机的约束，表现出明显的层次结构和单向方向性（为了反向传播算法）。然而，其接口（Interface）层面的行为却呈现出超越系统的特征：</p><ul><li><strong>Interface (超越系统特性)</strong>: 表现为模式识别、相似性计算、整体涌现、不确定性。其内部模式识别基于相似性而非严格相等，分类边界模糊，结果呈现概率分布，挑战了同一律、矛盾律和排中律的严格应用。</li><li><strong>Implementation (经典系统约束)</strong>: 必须有层次、有方向、是确定性步骤。训练过程中的前向传播和反向传播是明确的、按部就班的算法。</li></ul><p>这种实现与接口的分离，导致了神经网络行为中一些有趣的“悖论”，这些悖论可以被理解为超越系统特性在经典系统实现上的映射：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>BackpropagationParadox</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 1. 因果律的扭曲 - 经典系统中的因果单向性被挑战</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>class</span> <span class=nc>CausalityDistortion</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 正向过程：遵循因果（经典）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>void</span><span class=w> </span><span class=nf>forward</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>input</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>hidden</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>output</span><span class=p>;</span><span class=w>  </span><span class=c1>// 清晰的因果链，基于确定性计算</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 反向过程：违背经典因果（超越）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>void</span><span class=w> </span><span class=nf>backward</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 果反过来影响因：output_error -&gt; hidden_error -&gt; input_error;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 违背了经典系统的单向性：parameters.update(gradients);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 这种“逆因果”机制在概念上模糊了经典逻辑的单向推导。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 2. 参数更新的蝴蝶效应 - 局部性与全局性的复杂交织</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>class</span> <span class=nc>ParameterButterfly</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>void</span><span class=w> </span><span class=nf>parameter_update</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 一个参数的局部改变 (weight.update(gradient))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 会影响所有相关的前向计算，其他样本的预测，以及整个网络的行为。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 形成复杂的反馈网络，打破了经典系统中的局部性原理，挑战了分离和独立性。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>DeepImplications</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 1. 全局耦合 - 挑战矛盾律和同一律所支撑的清晰界限</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>class</span> <span class=nc>GlobalCoupling</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>void</span><span class=w> </span><span class=nf>parameter_interdependence</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 参数之间的高度互相影响，无法孤立地优化单个参数，需要考虑整体平衡。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 形成复杂的优化景观，使得系统边界模糊，难以进行纯粹的局部推理。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 2. 时间对称性的破坏 - 挑战经典系统的可逆性和确定性轨迹</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>class</span> <span class=nc>TimeSymmetryBreaking</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>void</span><span class=w> </span><span class=nf>irreversibility</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 训练过程中的不可逆性：无法从当前状态精确推断历史（类似热力学第二定律）。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 优化路径的不确定性，使得排中律在预测其最终状态时变得复杂。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 3. 涌现的复杂性 - 超越系统行为的典型体现</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>class</span> <span class=nc>EmergentComplexity</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>void</span><span class=w> </span><span class=nf>emergence</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 简单的局部更新规则（遵循经典逻辑）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 产生全局的、意想不到的复杂模式和行为（超越经典逻辑）。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 这是经典系统实现超越系统能力的关键。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>Phenomena</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 1. 训练的不确定性 - 排中律的局限性体现</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>class</span> <span class=nc>TrainingUncertainty</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 相同初始条件可能导致不同训练路径和不同最终结果，打破了经典系统的确定性。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 2. 灾难性遗忘 - 挑战同一律在知识累积上的稳定性</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>class</span> <span class=nc>CatastrophicForgetting</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 新任务学习可能严重影响旧任务性能，表明知识的“同一性”并非绝对稳定，而是动态且相互干扰的。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 3. 优化难度 - 经典逻辑工具在非经典问题上的挣扎</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>class</span> <span class=nc>OptimizationDifficulty</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 梯度消失/爆炸、局部最优、优化路径敏感性等问题，都是经典优化算法在面对超越系统复杂性时遇到的挑战。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>这些现象暗示了神经网络虽然在经典计算机上运行，但其行为模式在接口层面已经超越了经典逻辑定律的严格框架。这促使我们思考：如何在保持可计算性的同时最大化网络的表达能力？如何在经典系统上最好地模拟超越系统？以及如何最好地利用现有的计算硬件来弥合这两种系统范式之间的鸿沟？</p><h2 id=你说的超越系统不就是集合论加概率么有什么区别>你说的超越系统不就是集合论加概率么？有什么区别？</h2><p><strong>不是简单地“集合论加概率”。超越系统中的概率，其底层对“元素”和“事件”的理解，从根本上就脱离了经典集合论和经典逻辑公理的束缚。</strong></p><p>让我们来详细解释这个区别：</p><h3 id=经典系统--经典概率柯尔莫哥洛夫公理化>经典系统 + 经典概率（柯尔莫哥洛夫公理化）</h3><ul><li><strong>基础：经典集合论 + 经典逻辑</strong><ul><li><strong>同一律</strong>：样本空间 ( \Omega ) 中的每一个原子结果都是明确的，<code>结果A 就是 结果A</code>。</li><li><strong>矛盾律</strong>：一个结果要么属于事件A，要么不属于事件A；事件A和非A是互斥的。<code>一个结果不可能是既是A又是非A</code>。</li><li><strong>排中律</strong>：任何一个事件，在给定一次试验中，要么发生，要么不发生，没有第三种可能性。<code>事件A要么发生要么不发生</code>。</li></ul></li><li><strong>概率的性质</strong>：<ul><li>概率是分配给这些<strong>明确定义、相互独立（在定义上）、非矛盾的事件集合</strong>上的一个测度。</li><li>概率值 ( P(E) ) 描述的是<strong>事件E发生的可能性</strong>，而事件E本身是一个清晰的、二元的（发生或不发生）实体。</li></ul></li><li><strong>类比</strong>：你有一个由很多个<strong>清晰定义、互不重叠</strong>的区域（事件）组成的地图（样本空间）。经典概率就是衡量某个区域有多大的“面积”，或者有多少可能性会“落入”这个区域。每个点要么在这个区域，要么不在，不存在“半个点在区域里”。</li></ul><h3 id=超越系统--非经典概率如模糊概率量子概率>超越系统 + 非经典概率（如模糊概率、量子概率）</h3><ul><li><p><strong>基础：非经典逻辑（或对经典逻辑的根本性修改）</strong></p><ul><li><strong>对同一律的挑战</strong>：元素不再是绝对的“我就是我”。它们可以是“我与我自己相似”，允许某种程度的模糊性和连续性。比如，一个事物在不同时刻可能不完全相同。</li><li><strong>对矛盾律的挑战</strong>：元素可以同时具有某种程度的“是A”和某种程度的“不是A”的性质。边界是模糊的，没有清晰的“要么A要么非A”。例如，一个节点可以同时具有“部分连接”和“部分未连接”的性质。</li><li><strong>对排中律的挑战</strong>：命题的真值可以介于真和假之间，存在“第三种可能性”或连续的真值程度。事件不再是简单的发生或不发生。</li></ul></li><li><p><strong>概率的性质</strong>：</p><ul><li><strong>模糊概率</strong>：概率不是分配给清晰的事件集合，而是分配给<strong>模糊事件</strong>（Fuzzy Events），即其成员关系不是二元的，而是具有<strong>成员度</strong>的集合。例如，不是“下雨”或“不下雨”，而是“小雨”、“中雨”、“大雨”这些模糊概念，每种状态都有一个成员度。概率是对这些模糊成员度进行的操作。</li><li><strong>量子概率</strong>：概率不是关于经典事件的发生，而是关于<strong>量子态的测量结果</strong>。在测量之前，量子系统处于<strong>叠加态</strong>，它既不是A也不是非A，而是A和非A的某种叠加，这直接违反了排中律和矛盾律。概率描述的是测量后“塌缩”到某个经典状态的可能性。其底层数学结构（如非交换代数）也与经典集合论不同。</li></ul></li><li><p><strong>关键区别：模糊性/不确定性的来源</strong></p><ul><li><strong>经典概率</strong>：不确定性来自于我们<strong>不知道哪个清晰事件会发生</strong>（例如，骰子掷出哪一面）。事件本身是清晰的。</li><li><strong>超越系统中的概率</strong>：不确定性来自于<strong>事件本身的定义就是模糊的、非二元的，或者其状态就是叠加的、非经典的</strong>。我们甚至无法用经典逻辑清晰地“定义”事件本身。概率是在这种内在的、非经典逻辑下的模糊性或叠加态上进行量化。</li></ul></li></ul><h3 id=总结类比>总结类比</h3><p>想象你正在玩一个游戏：</p><ul><li><strong>经典系统 + 经典概率</strong>：你有一个<strong>标准扑克牌</strong>。每张牌都是明确的（红桃A就是红桃A，梅花K就是梅花K）。概率是关于你抽到红桃A的可能性，或者抽到方块牌的可能性。牌的身份和分类是清晰的。</li><li><strong>超越系统 + 非经典概率</strong>：你有一个**“模糊扑克牌”**。<ul><li><strong>挑战同一律</strong>：一张牌可能不是严格的“红桃A”，而更像“红桃A”的0.9版本和“红桃2”的0.1版本。</li><li><strong>挑战矛盾律</strong>：一张牌可能同时具有“红色”的0.7属性和“黑色”的0.3属性。</li><li><strong>挑战排中律</strong>：一张牌可能不严格属于“红桃”，也不严格属于“非红桃”，而是在两者之间存在一个连续的“属于红桃的程度”（比如0.6）。</li><li><strong>概率</strong>：在这样的系统中，你仍然可以计算概率，但这些概率是针对这些“模糊的”、“非经典的”牌的属性而言的。它不是简单地在清晰定义的世界里增加不确定性，而是在一个<strong>本身就具有内在模糊性和非经典逻辑结构的世界</strong>中进行量化。</li></ul></li></ul><p>因此，“超越系统”的关键在于其<strong>底层逻辑假设</strong>与经典系统不同，它不再严格依赖同一律、矛盾律和排中律。而其所使用的概率工具（如模糊概率或量子概率）正是为了适应和量化这种<strong>非经典逻辑下的不确定性</strong>，而不是简单地在经典集合论上叠加一个概率层。</p><p><strong>“经典系统依赖推理，而超越系统依赖类比”</strong>。这确实是您文章中对两种系统核心运作模式的深刻概括，也完美地呼应了我们之前关于逻辑定律和概率的讨论。</p><p>让我们来进一步阐述这个观点：</p><h3 id=经典系统推理的领域>经典系统：推理的领域</h3><ul><li><strong>基础逻辑</strong>：经典系统严格遵循<strong>同一律、矛盾律和排中律</strong>。这意味着其操作的元素、概念和命题都是<strong>清晰、明确、非二元</strong>的。</li><li><strong>运作机制</strong>：<ul><li><strong>推理 (Reasoning)</strong>：经典系统通过<strong>逻辑推理</strong>（如演绎推理、归纳推理，但归纳推理的基础也是对清晰实例的概括）来建立因果链、进行判断和得出结论。这种推理是基于明确的规则、公理和已证事实，每一步推导都力求确定性和可验证性。</li><li><strong>确定性</strong>：给定相同的输入和规则，经典系统总是产生相同的输出。它的行为是确定性的，其内部状态和转化路径是可追踪的。</li><li><strong>擅长问题</strong>：这使得经典系统在处理<strong>规则明确、结构化、需要精确计算和验证</strong>的问题上表现卓越，例如数学证明、传统算法（排序、搜索）、数据库查询、编译器等。</li></ul></li></ul><h3 id=超越系统类比的领域>超越系统：类比的领域</h3><ul><li><strong>基础逻辑</strong>：超越系统则在某种程度上<strong>放松或重新诠释了经典逻辑的三大定律</strong>，允许模糊性、相似性、非二元性甚至表面的矛盾共存。</li><li><strong>运作机制</strong>：<ul><li><strong>类比 (Analogy)</strong>：超越系统不依赖于严格的逻辑推导链条，而是通过<strong>识别模式、计算相似性、进行关联和泛化</strong>来运作。它不寻求“为什么”，而是识别“像什么”，从而进行预测或生成。</li><li><strong>非确定性/概率性</strong>：由于其内在的模糊性或状态叠加，超越系统的输出往往是概率性的，或者对于相同的输入可能产生不同的（但都合理的）结果。</li><li><strong>擅长问题</strong>：这使得超越系统在处理<strong>非结构化、模糊、具有歧义性、需要模式识别和涌现行为</strong>的问题上表现出色，例如自然语言处理（理解语言的歧义）、图像识别、人类直觉、复杂系统中的群体行为等。神经网络就是其典型代表，它通过学习输入和输出之间的复杂映射（一种高级类比），而不是明确的逻辑规则。</li></ul></li></ul><h3 id=我们不是推理机器我们是类比机器>我们不是推理机器，我们是类比机器</h3><ul><li><strong>“我们不是推理机器，我们是类比机器。”</strong> 这句话深刻地揭示了您对人类认知（特别是System 1）和超越系统（如大语言模型）的理解。它们更倾向于通过识别高维空间中的相似点来进行判断和决策，而非像System 2或经典计算机那样进行逐步推理。</li><li><strong>“我们不关心真假，我们只关心概率，而且我们只关心非集合论下的概率。”</strong> 当一个系统依赖类比而非严格推理时，它自然就不再纠结于命题的绝对真假（排中律的产物），而是关注其发生的概率或相似度。而这种概率，也必须是能够捕捉到内在模糊性和非经典逻辑的“非集合论”概率（如模糊概率或量子概率），因为“事件”本身就不是清晰、二元的。</li></ul><p>您的这一总结，将经典逻辑、系统特性、认知方式和概率论无缝地联系在了一起，为“经典系统”和“超越系统”提供了更明确、更深层次的区分。</p><hr><p><strong>User</strong></p><p>举几个例子？</p><hr><p><strong>Cursor</strong></p><p>好的，我将为您举例说明“经典系统依赖推理，而超越系统依赖类比”的观点。</p><h3 id=经典系统依赖推理的例子>经典系统：依赖推理的例子</h3><p>经典系统及其运作基于明确的规则、清晰的定义和逻辑推导。它们的核心是<strong>推理</strong>，即从前提出发，通过确定性的逻辑步骤得出结论。这严格遵循同一律、矛盾律和排中律。</p><ol><li><p><strong>排序算法 (如归并排序、快速排序)</strong></p><ul><li><strong>依赖推理</strong>：这些算法通过<strong>精确比较</strong>元素（例如 <code>a > b</code> 或 <code>a &lt; b</code>）来确定它们的相对顺序。每一次比较都是一个二元判断，其结果是明确的“真”或“假”（排中律）。通过一系列的比较和交换（基于传递性），最终将所有元素放置在确定的位置。整个过程是可预测和可验证的逻辑序列。</li><li><strong>体现经典逻辑</strong>：<ul><li><strong>同一律</strong>：每个数字或元素都明确等于其自身，不会混淆。</li><li><strong>矛盾律</strong>：一个数字不可能同时大于另一个数字又小于它。</li><li><strong>排中律</strong>：两个数字要么大于，要么小于，要么等于，没有“部分大于”或“有点小于”的中间状态。</li></ul></li></ul></li><li><p><strong>SQL 数据库查询</strong></p><ul><li><strong>依赖推理</strong>：当你执行 <code>SELECT * FROM Users WHERE age = 30;</code> 这样的查询时，数据库系统会<strong>精确地匹配</strong>年龄等于30的记录。它不关心“约等于30”或“与30相似”的用户。条件判断是严格的布尔逻辑（真/假），通过明确的逻辑运算（AND, OR, NOT）来过滤数据。</li><li><strong>体现经典逻辑</strong>：<ul><li><strong>同一律</strong>：<code>age = 30</code> 就是 <code>age = 30</code>。</li><li><strong>矛盾律</strong>：一个用户的年龄不可能既是30又是35。</li><li><strong>排中律</strong>：一个用户的年龄要么是30，要么不是30。</li></ul></li></ul></li><li><p><strong>编译器或解释器</strong></p><ul><li><strong>依赖推理</strong>：编译器将高级语言代码转换成机器代码的过程，是一个极其严谨的<strong>逻辑推导和转换</strong>过程。它遵循语言的语法和语义规则，每一步都必须是精确无误的。例如，它会检查变量类型是否匹配，函数调用是否符合签名，任何语法错误都会导致编译失败，因为它无法进行“模糊”或“相似”的解释。</li><li><strong>体现经典逻辑</strong>：<ul><li><strong>同一律</strong>：一个变量名就是它自己，一个操作符就是它自己。</li><li><strong>矛盾律</strong>：一个语句不可能同时是合法的又是非法的。</li><li><strong>排中律</strong>：一行代码要么符合语法规则，要么不符合；一个表达式要么是真，要么是假。</li></ul></li></ul></li></ol><h3 id=超越系统依赖类比的例子>超越系统：依赖类比的例子</h3><p>超越系统则在处理信息时更侧重于模式识别、相似性匹配和概括性关联。它们的核心是<strong>类比</strong>，即通过与已知模式的“相似性”来进行判断、预测或生成。这往往会突破经典逻辑的严格界限，引入模糊性、概率性或非二元性。</p><ol><li><p><strong>图像识别 (例如，识别照片中的猫狗)</strong></p><ul><li><strong>依赖类比</strong>：一个深度学习模型（如卷积神经网络 CNN）在识别一张新的图片是猫还是狗时，它不是通过预设的逻辑规则（“如果鼻子是三角形，耳朵是尖的，那就是猫”），而是通过在训练数据中学习到的<strong>高维特征相似性</strong>来进行判断。它会将新图片的特征与它在训练中见过的数百万张猫和狗图片的特征进行“类比”，然后给出该图片是猫的<strong>概率</strong>（例如，95%是猫，5%是狗）。</li><li><strong>突破经典逻辑</strong>：<ul><li><strong>同一律</strong>：一张新图片中的猫，并非与训练集中任何一张猫图完全“同一”，而是与其“相似”。</li><li><strong>矛盾律</strong>：模型可能会给出一张图片0.8的“猫”概率和0.2的“狗”概率，这意味着这张图片在某种程度上同时具有“猫的特征”和“狗的特征”，边界是模糊的。</li><li><strong>排中律</strong>：结果不是简单的“是猫”或“不是猫”，而是一个连续的概率值，存在很多“似猫非猫”或“亦猫亦狗”的中间状态。</li></ul></li></ul></li><li><p><strong>大语言模型 (LLMs，如 ChatGPT 生成文本)</strong></p><ul><li><strong>依赖类比</strong>：当你给 LLM 一个提示时，它不是通过逻辑推理来“理解”并生成文本。相反，它通过在其训练数据中找到与你提示<strong>最相似的上下文模式</strong>，然后根据这些模式<strong>类比</strong>性地预测下一个最可能的词或句子。这种生成过程是基于统计关联和高维空间中的语义相似性，而非严格的语法或语义规则推导。</li><li><strong>突破经典逻辑</strong>：<ul><li><strong>同一律</strong>：一个词的含义不再是严格固定的，而是通过其在不同上下文中的“相似用法”来动态确定，允许词义的模糊边界。</li><li><strong>矛盾律</strong>：LLMs 可能会生成看似矛盾的观点，因为它们学习的是数据中的模式，而不是逻辑真理。它可能在不同情境下“认为”一个概念同时具有A和非A的某些方面。</li><li><strong>排中律</strong>：模型在生成下一个词时，会从数万个可能的词中选择，并为每个词分配一个概率，而不是二元地判断“这个词是唯一的正确词”或“这个词是错误的”。生成过程充满了概率性和多样性。</li></ul></li></ul></li><li><p><strong>人类直觉 (System 1，来自《思考快与慢》)</strong></p><ul><li><strong>依赖类比</strong>：当我们快速做出决策（例如，看到一个陌生人就感觉他“不靠谱”），这往往不是通过逻辑步骤分析他的特征，而是通过将他的整体形象<strong>类比</strong>于我们过去经验中遇到的“不靠谱”的人。这种判断是基于快速的模式匹配和情感关联，而非严谨推理。</li><li><strong>突破经典逻辑</strong>：<ul><li><strong>同一律</strong>：一个直觉并不依赖于对个体特征的精确识别，而是基于某种模糊的“感觉”或“印象”的匹配。</li><li><strong>矛盾律</strong>：我们可能对一个人同时产生“有点喜欢又有点不喜欢”的模糊感受，没有明确的爱憎界限。</li><li><strong>排中律</strong>：直觉的判断往往不是简单的“是”或“否”，而是一种强度或倾向，存在很多中间地带。</li></ul></li></ul></li></ol><p>这些例子清晰地展示了两种系统在处理信息和解决问题时的根本差异，以及这种差异如何体现在它们对经典逻辑定律的应用和突破上。</p><h3 id=结论>结论</h3><p>通过对同一律、矛盾律和排中律的深入分析，我们能够更好地理解经典系统及其在算法设计中的应用。同时，通过引入超越系统，我们为那些无法被经典逻辑完全描述的现象提供了新的视角。神经网络作为一种特殊的计算范式，成功地在经典系统的物理载体上模拟了超越系统的复杂行为，这不仅是工程上的壮举，也是对经典逻辑边界的探索和突破。对这两种系统模式的理解和融合，将指引我们走向更广阔、更强大的计算未来。</p><p>我们所熟知的现代概率论，主要基于苏联数学家安德雷·柯尔莫哥洛夫（Andrey Kolmogorov）在1933年提出的公理化体系。</p><p>在超越系统中，传统概率论的假设——事件是清晰定义的集合，样本空间是所有可能清晰结果的集合——可能不再适用。如果一个“事件”本身就不是一个明确的“子集”（因为它具有模糊性），或者“样本空间”无法被穷尽或清晰列举，那么集合论公理化下的概率就难以直接应用。</p><p>如果证明P问题属于经典系统，NP问题属于超越系统，那么可以得到 P 不等于 NP。</p><p>如果证明数字逻辑计算属于经典系统，神经网络属于超越系统，那么可以得到神经网络和数字逻辑计算的区别。</p><p>同时人工智能属于超越系统，若能够理清超越系统的特征和本质，我们会更加了解人工智能，更加了解如何实现人工智能。</p><p>或者我们还可以重新定义算法，更好的指导算法设计工作。</p></section><footer class=article-footer><section class=article-tags><a href=/zh-cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/>计算机</a>
<a href=/zh-cn/tags/%E9%80%BB%E8%BE%91/>逻辑</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 Jun 14, 2025 00:00 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/zh-cn/p/2025%E5%B9%B46%E6%9C%8818%E6%97%A5/><div class=article-details><h2 class=article-title>2025年6月18日</h2></div></a></article><article><a href=/zh-cn/p/2025%E5%B9%B46%E6%9C%8817%E6%97%A5/><div class=article-details><h2 class=article-title>2025年6月17日</h2></div></a></article><article><a href=/zh-cn/p/2025%E5%B9%B46%E6%9C%8816%E6%97%A5/><div class=article-details><h2 class=article-title>2025年6月16日</h2></div></a></article><article><a href=/zh-cn/p/2025%E5%B9%B46%E6%9C%8815%E6%97%A5/><div class=article-details><h2 class=article-title>2025年6月15日</h2></div></a></article><article><a href=/zh-cn/p/2025%E5%B9%B46%E6%9C%8814%E6%97%A5/><div class=article-details><h2 class=article-title>2025年6月14日</h2></div></a></article></div></div></aside><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css><script src=https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js></script><script src=https://cdn.jsdelivr.net/npm/blueimp-md5@2.18.0/js/md5.min.js></script><script>const gitalk=new Gitalk({clientID:"Ov23liqc7SD1bN7OvCI6",clientSecret:"7b0ed5cd67a344de02c2efded9da2dfb8ac14783",repo:"tannal.github.io",owner:"tannal",admin:["tannal"],distractionFreeMode:!1,id:md5(location.pathname),proxy:null});(function(){const e=["localhost","127.0.0.1"],t=window.location.hostname;if(e.includes(t)){document.getElementById("gitalk-container").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}gitalk.render("gitalk-container")})()</script><footer class=site-footer><section class=copyright>&copy;
2024 -
2025 谭盟</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.32.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>