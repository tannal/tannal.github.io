---
title: 计算机和神经网络
date: 2025-02-07T10:51:56+08:00
categories:
    - 计算机
    - 神经网络
tags:
---

## 重新定义算法

我们重新定义算法，沿着一个明确的方向单向前进，
并且在过程中建立起沿方向传递的单调或独立性质的计算机程序

整数和一般意义上的离散系统具备以下性质

1. 自反性质，我等于我自己
2. 区别性质，除了我以外没人跟我一样
3. 传递性质，也叫鄙视链性质，我跟别人不一样，不仅不一样，一定能分出高下。

传递性质可以形成鄙视链机制，也就是层级关系。

传递性质的利用是算法时间复杂度差异的来源，简单来说利用传递性质分批处理能够减小算法的时间复杂度。

--- 这部分还没想好，暂时用Claude3内容代替 ---

```

class SortingAlgorithms {
    // 1. 传递性质的利用
    class TransitiveProperty {
        // 比较关系的传递性
        void compare() {
            // if a > b && b > c then a > c
            // 这个性质允许我们：
            // 1. 不需要比较所有对
            // 2. 可以批量处理
            // 3. 保证结果正确性
        }
    }
    
    // 2. 不同批次大小的实现
    class BatchProcessing {
        // 插入排序 (批次=1)
        void insertionSort() {
            // 一次处理一个元素
            // O(n^2) - 没有利用批处理
        }
        
        // 归并排序 (批次=n/2)
        void mergeSort() {
            // 每次处理一半数据
            // O(n log n) - 批处理带来优化
        }
        
        // 快速排序 (批次=基于pivot的分区)
        void quickSort() {
            // 动态批次大小
            // O(n log n) - 平均情况
        }
        
        // 堆排序 (批次=堆的层级)
        void heapSort() {
            // 利用堆的性质批处理
            // O(n log n) - 稳定的批处理
        }
    }
}
```

--- 这部分还没想好，暂时用Claude3内容代替 ---


计算机无法解决没有方向单向前进，同时不具备传递性质的计算问题
计算机只能处理有明确方向性和沿着方向性传递单调或独立性质的结构

时间在分布式系统中被理解为事件的发生顺序，顺序这个概念同时满足三个性质。

计算机科学中的树是层级系统最完美的体现，层级系统也是人类的 System 2 的运行基础。

计算机对于实数连续域上的问题求解的困难很大程度上来自于实数不具备上面三个性质。

使得处理自然科学问题的计算机科学家不得不开发出各种数值算法和半数值算法。

## 经典系统

1. 自反性质，我等于我自己
2. 区别性质，除了我以外没人跟我一样
3. 传递性质，也叫鄙视链性质，我跟别人不一样，不仅不一样，一定能分出高下。

满足这三个性质的系统，我们称之为经典系统。

这类系统最典型的特征就是存在单方向性质，树形结构是最完美的呈现。

如数学中的公理定理推论系统，公理是树根，定理推论是树枝树叶。

数学严密化成这样得益于人类的System 2也就是逻辑推理自己就是这种满足性质的系统。

逻辑推理的根源是有因必有果，这形成了最基本的经典系统，满足1.因果是不一样的，2.因是因，果是果，3.因导致的果，而不是果导致的因，满足传递性质。

这是现代科学的基础，那这个世界上有没有不存在因果关系，或者讲不清因果关系的现象呢？

有

1. 生命体群体行为，如股市，消费者行为，蚁群
2. 量子力学，如双缝干涉实验
3. 经典力学的三体系统
4. 人类直觉，如《思考快与慢》中的 System 1
5. 大语言模型，直指NLP中的根本问题——如何处理语言中的歧义
6. 感知与意识，如视觉错觉，平行透视
7. 艺术创作，如音乐，绘画
8. 睡眠中的主观体验现象
9. 哥德尔不完备定理
...

经典系统里面的第一大难题也是造成无数科学数学计算机系统问题的根源就是自指。

例如语言中的歧义，逻辑问题，停机问题，不可判定问题

自指来自于自反性质，即我就是我。

如鸡生蛋蛋生鸡问题，答案是

不是所有的鸡都会生蛋，也不是所有的鸡都是蛋生来的。

计算机科学家早有无数的办法应付自指，他们甚至自己创造自指

如既然编程语言需要编译器，世界上第一个编程语言的编译器是用什么写的？
答案是机器语言不需要编译器，他需要链接器，反正不需要编译器，编程语言都需要编译器本身就是错的。

计算机科学家可以通过重复造轮子自己创造自指

例如用clang编译clang得到的可执行程序可以编译自己形成一个新的clang可执行文件

又或者我的世界里面可以造一个计算机。

还有qemu这类虚拟机器，可以运行虚拟机。

还有语言的运行时如JVM，里头自己实现了个CPU，然后跑在你买的英特尔的CPU上面也是典型的自指，怎么没有出现什么英特尔CPU递归爆炸这种类似逻辑递归自指的问题？

自指的根源就是三大性质

1. 自反性质，我等于我自己
2. 区别性质，除了我以外没人跟我一样
3. 传递性质，也叫鄙视链性质，我跟别人不一样，不仅不一样，一定能分出高下。

另一个世界不满足三大性质，不满足因果律，至少表面上看起来不满足，无法区分自己和别人。

## 超越系统

不满足这三个性质的系统，我们称之为超越系统，我们之前已经描述过常见的超越系统。

现在我们尝试描述超越系统的基本特点，超越系统与经典系统最根本的区别是从刻画相等与不等到刻画相似与不相似

1. 相似性质，我与我自己相似
2. 区别性质，我与别人不相似
3. 平等性质，我与别人的不相似，无法区分高下

由于哥德尔不完备定理，我们总能在经典系统中意外发现超越现象。

最典型的能够在经典系统就观察到的超越现象就是因果循环，单向的因果关系链条被打破。

Q：上海市的经济为什么好？
A：因为有大量的劳动人口和就业机会。

Q：为什么上海市有大量的劳动人口和就业机会？
A：因为上海市的经济好。

数学家用公理系统解决了可能涉及的自指问题。

语言学家也早已注意到词典中的循环定义问题，每一个单词都由其他单词定义。

计算机科学中图结构没有明显的层次结构，尽管特殊的图有（如DAG），但层次结构不是图的一般性质。

图的一般性质是每个节点都可以有关系，这种关系可以用相似性刻画强弱，但图无法刻画两个节点相同。

一般图满足超越系统的特点，他是计算理论最最喜欢研究的对象之一，一般图中的各种性质涵盖了大量NP问题。

另一个满足超越系统特性的是神经网络

1. 相似性而非相等性

 没有完全相同的输入

 相似的输入可能产生相似的输出

 相似度是连续的而非离散的

2. 分类边界是模糊的

 边界案例难以判定

 分类结果是概率分布

 同一输入可能有不同解释

值得一提的是，超越系统中不存在自指问题，因为超越系统中不存在自己这个概念

在超越系统中：

1. 没有"相等"的概念

即使是"自己"也只是相似
每一刻的"我"都是不同的
只有相似，没有相等

2. 无法确定"自己"

"我"是模糊的概念
边界是不确定的
无法精确定义"自己"

3. 不存在自反性

不能说"我就是我"
因为没有确定的"我"
只有相似度的连续变化

这也是为什么，你可以跟LLM玩角色扮演。
你也可以跟你的好朋友们玩角色扮演。


## 所以呢？

计算机科学家能用计算机这种经典系统做出大语言模型这种超越系统简直就是奇迹。

不过这也从侧面证明的哥德尔不完备定理的普适性和一般性。

如果神经网络属于超越系统，那他为何有明显的层次结构和方向性？

这涉及到interface和implementation的问题

由于神经网络实现在经典计算机上，他似乎受到经典计算机系统的约束

如明显的层次结构和单向的方向限制，似乎是为了方便反向传播算法，区分前向传播和反向传播过程

1. Interface（超越系统的接口和目标）

表现为超越系统，有模式识别、相似性计算、整体涌现、不确定性这些特征

无明确层次

无固定方向

网络式关联

2. Implementation（在经典系统的实现）

必须有层次

必须有方向

必须是确定性步骤

所以区分前向传播和反向传播，这种训练与推理的分离

训练时（实现层）

显示层次结构

明确的方向性

确定性算法

推理时（接口层）

表现整体性

模糊的边界

涌现的行为

神经网络被经典计算机约束，无法完全有效的模拟生物神经网络?

如何在经典系统上最好地模拟超越系统？

如何在保持可计算性的同时最大化网络的表达能力？

如何最好地利用现有的计算硬件？

--- 神经网络这段应该还有别的没提到的，暂时用claude3的内容代替 ---

```
class BackpropagationParadox {
    // 1. 因果律的扭曲
    class CausalityDistortion {
        // 正向过程：遵循因果
        void forward() {
            input -> hidden -> output;  // 清晰的因果链
        }
        
        // 反向过程：违背因果
        void backward() {
            // 果反过来影响因
            output_error -> hidden_error -> input_error;
            
            // 违背了经典系统的单向性
            parameters.update(gradients);
        }
    }
    
    // 2. 参数更新的蝴蝶效应
    class ParameterButterfly {
        void parameter_update() {
            // 一个参数的改变
            weight.update(gradient);
            
            // 会影响
            // - 所有相关的前向计算
            // - 其他样本的预测
            // - 整个网络的行为
            
            // 形成复杂的反馈网络
            // 打破了局部性原理
        }
    }
}

```


```
class DeepImplications {
    // 1. 全局耦合
    class GlobalCoupling {
        // 参数之间的互相影响
        void parameter_interdependence() {
            // 无法孤立地优化单个参数
            // 需要考虑整体平衡
            // 形成复杂的优化景观
        }
    }
    
    // 2. 时间对称性的破坏
    class TimeSymmetryBreaking {
        // 训练过程中的不可逆性
        void irreversibility() {
            // 无法从当前状态推断历史
            // 优化路径的不确定性
            // 类似热力学第二定律
        }
    }
    
    // 3. 涌现的复杂性
    class EmergentComplexity {
        // 简单规则产生复杂行为
        void emergence() {
            // 局部更新规则
            // 产生全局模式
            // 类似复杂系统
        }
    }
}

```

```
class Phenomena {
    // 1. 训练的不确定性
    class TrainingUncertainty {
        // 相同初始条件
        // 不同训练路径
        // 不同最终结果
    }
    
    // 2. 灾难性遗忘
    class CatastrophicForgetting {
        // 新任务学习
        // 影响旧任务性能
        // 全局知识相互干扰
    }
    
    // 3. 优化难度
    class OptimizationDifficulty {
        // 梯度消失/爆炸
        // 局部最优
        // 优化路径敏感
    }
}
```

--- 神经网络这段应该还有别的没提到的，暂时用claude3的内容代替 ---